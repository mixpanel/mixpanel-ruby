<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Mixpanel::Consumer - RDoc Documentation</title>

<link href="../fonts.css" rel="stylesheet">
<link href="../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/navigation.js"></script>
<script src="../js/search_index.js"></script>
<script src="../js/search.js"></script>
<script src="../js/searcher.js"></script>
<script src="../js/darkfish.js"></script>


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-request">#request</a>
    
    <li ><a href="#method-i-send">#send</a>
    
    <li ><a href="#method-i-send-21">#send!</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Mixpanel::Consumer">
  <h1 id="class-Mixpanel::Consumer" class="class">
    class Mixpanel::Consumer
  </h1>

  <section class="description">
    
<p>A <a href="Consumer.html">Consumer</a> receives messages from a <a
href="Tracker.html">Mixpanel::Tracker</a>, and sends them elsewhere-
probably to Mixpanel&#39;s analytics services, but can also enqueue them
for later processing, log them to a file, or do whatever else you might
find useful.</p>

<p>You can provide your own consumer to your Mixpanel::Trackers, either by
passing in an argument with a <a
href="Consumer.html#method-i-send-21">send!</a> method when you construct
the tracker, or just passing a block to <a
href="Tracker.html#method-c-new">Mixpanel::Tracker.new</a></p>

<pre class="ruby"><span class="ruby-identifier">tracker</span> = <span class="ruby-constant">Mixpanel</span><span class="ruby-operator">::</span><span class="ruby-constant">Tracker</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">MY_TOKEN</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">type</span>, <span class="ruby-identifier">message</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># type will be one of :event, :profile_update or :import</span>
    <span class="ruby-ivar">@kestrel</span>.<span class="ruby-identifier">set</span>(<span class="ruby-constant">ANALYTICS_QUEUE</span>, [<span class="ruby-identifier">type</span>, <span class="ruby-identifier">message</span>].<span class="ruby-identifier">to_json</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>You can also instantiate the library consumers yourself, and use them
wherever you would like. For example, the working that consumes the above
queue might work like this:</p>

<pre>mixpanel = Mixpanel::Consumer
while true
    message_json = @kestrel.get(ANALYTICS_QUEUE)
    mixpanel.send!(*JSON.load(message_json))
end</pre>

<p><a href="Consumer.html">Mixpanel::Consumer</a> is the default consumer. It
sends each message, as the message is recieved, directly to Mixpanel.</p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-new" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(events_endpoint=nil, update_endpoint=nil, import_endpoint=nil)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Create a <a href="Consumer.html">Mixpanel::Consumer</a>. If you provide
endpoint arguments, they will be used instead of the default Mixpanel
endpoints. This can be useful for proxying, debugging, or if you prefer not
to use SSL for your events.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre><span class="ruby-comment"># File lib/mixpanel-ruby/consumer.rb, line 70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">events_endpoint</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">update_endpoint</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">import_endpoint</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-ivar">@events_endpoint</span> = <span class="ruby-identifier">events_endpoint</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;https://api.mixpanel.com/track&#39;</span>
  <span class="ruby-ivar">@update_endpoint</span> = <span class="ruby-identifier">update_endpoint</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;https://api.mixpanel.com/engage&#39;</span>
  <span class="ruby-ivar">@import_endpoint</span> = <span class="ruby-identifier">import_endpoint</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;https://api.mixpanel.com/import&#39;</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-request" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">request</span><span
            class="method-args">(endpoint, form_data)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Request takes an endpoint HTTP or HTTPS url, and a Hash of data to post to
that url. It should return a pair of</p>
<dl class="rdoc-list label-list"><dt>response code, response body
<dd>
<p>as the result of the response. Response code should be nil if the request
never receives a response for some reason.</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="request-source">
            <pre><span class="ruby-comment"># File lib/mixpanel-ruby/consumer.rb, line 130</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">request</span>(<span class="ruby-identifier">endpoint</span>, <span class="ruby-identifier">form_data</span>)
  <span class="ruby-identifier">uri</span> = <span class="ruby-constant">URI</span>(<span class="ruby-identifier">endpoint</span>)
  <span class="ruby-identifier">request</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span><span class="ruby-operator">::</span><span class="ruby-constant">Post</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">request_uri</span>)
  <span class="ruby-identifier">request</span>.<span class="ruby-identifier">set_form_data</span>(<span class="ruby-identifier">form_data</span>)

  <span class="ruby-identifier">client</span> = <span class="ruby-constant">Net</span><span class="ruby-operator">::</span><span class="ruby-constant">HTTP</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">uri</span>.<span class="ruby-identifier">host</span>, <span class="ruby-identifier">uri</span>.<span class="ruby-identifier">port</span>)
  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">use_ssl</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">open_timeout</span> = <span class="ruby-value">2</span>
  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">continue_timeout</span> = <span class="ruby-value">10</span>
  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">read_timeout</span> = <span class="ruby-value">10</span>
  <span class="ruby-identifier">client</span>.<span class="ruby-identifier">ssl_timeout</span> = <span class="ruby-value">2</span>

  <span class="ruby-constant">Mixpanel</span>.<span class="ruby-identifier">with_http</span>(<span class="ruby-identifier">client</span>)

  <span class="ruby-identifier">response</span> = <span class="ruby-identifier">client</span>.<span class="ruby-identifier">request</span>(<span class="ruby-identifier">request</span>)
  [<span class="ruby-identifier">response</span>.<span class="ruby-identifier">code</span>, <span class="ruby-identifier">response</span>.<span class="ruby-identifier">body</span>]
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send</span><span
            class="method-args">(type, message)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>This method was deprecated in release 2.0.0, please use send! instead</p>
          
          

          
          <div class="method-source-code" id="send-source">
            <pre><span class="ruby-comment"># File lib/mixpanel-ruby/consumer.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">message</span>)
    <span class="ruby-identifier">warn</span> <span class="ruby-string">&#39;[DEPRECATION] send has been deprecated as of release 2.0.0, please use send! instead&#39;</span>
    <span class="ruby-identifier">send!</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">message</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-send-21" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">send!</span><span
            class="method-args">(type, message)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Send the given string message to Mixpanel. Type should be one of :event,
:profile_update or :import, which will determine the endpoint.</p>

<p><a href="Consumer.html#method-i-send-21">#send!</a> sends messages to
Mixpanel immediately on each call. To reduce the overall bandwidth you use
when communicating with Mixpanel, you can also use <a
href="BufferedConsumer.html">Mixpanel::BufferedConsumer</a></p>
          
          

          
          <div class="method-source-code" id="send-21-source">
            <pre><span class="ruby-comment"># File lib/mixpanel-ruby/consumer.rb, line 82</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">send!</span>(<span class="ruby-identifier">type</span>, <span class="ruby-identifier">message</span>)
  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">type</span>.<span class="ruby-identifier">to_sym</span>
  <span class="ruby-identifier">endpoint</span> = {
    <span class="ruby-value">:event</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@events_endpoint</span>,
    <span class="ruby-value">:profile_update</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@update_endpoint</span>,
    <span class="ruby-value">:import</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-ivar">@import_endpoint</span>,
  }[<span class="ruby-identifier">type</span>]

  <span class="ruby-identifier">decoded_message</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">load</span>(<span class="ruby-identifier">message</span>)
  <span class="ruby-identifier">api_key</span> = <span class="ruby-identifier">decoded_message</span>[<span class="ruby-string">&quot;api_key&quot;</span>]
  <span class="ruby-identifier">data</span> = <span class="ruby-constant">Base64</span>.<span class="ruby-identifier">encode64</span>(<span class="ruby-identifier">decoded_message</span>[<span class="ruby-string">&quot;data&quot;</span>].<span class="ruby-identifier">to_json</span>).<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&quot;\n&quot;</span>, <span class="ruby-string">&#39;&#39;</span>)

  <span class="ruby-identifier">form_data</span> = {<span class="ruby-string">&quot;data&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">data</span>, <span class="ruby-string">&quot;verbose&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}
  <span class="ruby-identifier">form_data</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-string">&quot;api_key&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">api_key</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">api_key</span>

  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">response_code</span>, <span class="ruby-identifier">response_body</span> = <span class="ruby-identifier">request</span>(<span class="ruby-identifier">endpoint</span>, <span class="ruby-identifier">form_data</span>)
  <span class="ruby-keyword">rescue</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">e</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ConnectionError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;Could not connect to Mixpanel, with error \&quot;#{e.message}\&quot;.&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">result</span> = {}
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">response_code</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">==</span> <span class="ruby-value">200</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">result</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">response_body</span>.<span class="ruby-identifier">to_s</span>)
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">JSON</span><span class="ruby-operator">::</span><span class="ruby-constant">JSONError</span>
      <span class="ruby-identifier">raise</span> <span class="ruby-constant">ServerError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;Could not interpret Mixpanel server response: &#39;#{response_body}&#39;&quot;</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-string">&#39;status&#39;</span>] <span class="ruby-operator">!=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">ServerError</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;Could not write to Mixpanel, server responded with #{response_code} returning: &#39;#{response_body}&#39;&quot;</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

